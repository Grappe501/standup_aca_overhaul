---
// src/pages/[...slug].astro
import SiteLayout from "../layouts/SiteLayout.astro";
import { getCollection } from "astro:content";
import { sectionLabelFromRoute, titleizeSegment } from "../lib/sections";

type DocsCollection = Awaited<ReturnType<typeof getCollection<"docs">>>;
type DocEntry = DocsCollection[number];

function normalizePath(p: string): string {
  if (!p) return "/";
  let s = p.startsWith("/") ? p : "/" + p;

  // Collapse duplicate slashes (e.g. "//proposal//overview" -> "/proposal/overview")
  s = s.replace(/\/{2,}/g, "/");

  // Strip trailing slash (except root)
  if (s.length > 1 && s.endsWith("/")) s = s.slice(0, -1);

  return s;
}

function safeRouteFor(entry: DocEntry): string {
  const raw = entry.data.route || "/" + entry.slug;
  return normalizePath(raw);
}

function stripHtml(s: string): string {
  return s.replace(/<[^>]*>/g, "");
}

function slugToAnchor(s: string): string {
  return s
    .toLowerCase()
    .trim()
    .replace(/[’']/g, "")
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function routePathFromSlugParam(slugParam: unknown): string {
  // For [...slug], Astro.params.slug is typically string | undefined (not array).
  if (!slugParam) return "/";

  if (typeof slugParam === "string") {
    const s = slugParam.trim();
    if (!s) return "/";
    // slug may include "/" already, e.g. "congress/legislative"
    return normalizePath("/" + s.replace(/^\/+/, ""));
  }

  // Defensive fallback
  if (Array.isArray(slugParam)) {
    const joined = slugParam.filter(Boolean).join("/");
    return normalizePath("/" + joined);
  }

  try {
    const s = String(slugParam).trim();
    if (!s) return "/";
    return normalizePath("/" + s.replace(/^\/+/, ""));
  } catch {
    return "/";
  }
}

/**
 * Static routing:
 * Pre-render every content entry by its canonical `route` (preferred) or fallback slug.
 * Deterministic + static-host compatible.
 *
 * IMPORTANT: getStaticPaths must be fully self-contained (no outer helper refs),
 * because Astro/Vite transforms can otherwise trigger "X is not defined" at build time.
 */
export async function getStaticPaths() {
  // Self-contained normalizer (DO NOT reference outer normalizePath here)
  const normalize = (p: string): string => {
    if (!p) return "/";
    let s = p.startsWith("/") ? p : "/" + p;
    s = s.replace(/\/{2,}/g, "/");
    if (s.length > 1 && s.endsWith("/")) s = s.slice(0, -1);
    return s;
  };

  // Explicit pages already exist for these; don't duplicate them via catch-all.
  const reserved = new Set<string>([
    "/",
    "/index",
    "/start-here",
    "/congress",
    "/library",
    "/the-problem",
    "/the-backbone",
    "/proposal",
    "/loopholes",
    "/rural",
  ]);

  let docs: any[] = [];
  try {
    docs = await getCollection("docs");
  } catch {
    docs = [];
  }

  const seen = new Set<string>();
  const paths: Array<{ params: { slug?: string }; props: { routePath: string } }> = [];

  for (const d of docs) {
    // DO NOT call outer normalizePath here
    const routePath = normalize(d?.data?.route || "/" + d.slug);

    // Skip anything that collides with explicit pages
    if (reserved.has(routePath)) continue;

    if (seen.has(routePath)) continue;
    seen.add(routePath);

    // Astro expects catch-all param as a STRING like "a/b/c"
    const slug = routePath.replace(/^\//, "");

    paths.push({
      params: { slug: slug || undefined },
      props: { routePath },
    });
  }

  return paths;
}

// Load docs for rendering + navigation (build-safe)
let docs: DocEntry[] = [];
try {
  docs = (await getCollection("docs")) as unknown as DocEntry[];
} catch {
  docs = [];
}

const byRoute = new Map<string, DocEntry>(docs.map((d) => [safeRouteFor(d), d]));

// Determine current route from static props (preferred) or params (fallback)
const routePath =
  (Astro.props as any)?.routePath
    ? normalizePath((Astro.props as any).routePath)
    : routePathFromSlugParam(Astro.params.slug);

const entry = byRoute.get(routePath);

// Static-safe "not found" handling (no redirect in static build)
const notFound = !entry;

const title = notFound
  ? (sectionLabelFromRoute(routePath) ?? "Not Found")
  : (entry!.data.title ?? titleizeSegment(entry!.slug));

// Defaults (only populated when entry exists)
let Content: null | ((props: Record<string, any>) => any) = null;
let headings: any[] = [];

let ordered: DocEntry[] = [];
let prevEntry: DocEntry | null = null;
let nextEntry: DocEntry | null = null;

let segments: string[] = [];
let sectionLabel: string | null = null;
let sectionSlug: string | null = null;
let sectionHref: string | null = null;

let toc: Array<{ depth: number; text: string; slug: string }> = [];
let hasToc = false;

let permalink = normalizePath(routePath);

if (!notFound) {
  const rendered = await entry!.render();
  Content = rendered.Content as any;
  headings = rendered.headings ?? [];

  // For next/prev: sort docs by route then title for stable order
  ordered = docs
    .slice()
    .sort((a, b) => {
      const ra = safeRouteFor(a);
      const rb = safeRouteFor(b);
      const rcmp = ra.localeCompare(rb);
      if (rcmp !== 0) return rcmp;
      return (a.data.title ?? a.slug).localeCompare(b.data.title ?? b.slug);
    });

  const currentIndex = ordered.findIndex((d) => d.id === entry!.id);
  prevEntry = currentIndex > 0 ? ordered[currentIndex - 1] : null;
  nextEntry =
    currentIndex >= 0 && currentIndex < ordered.length - 1
      ? ordered[currentIndex + 1]
      : null;

  // Breadcrumbs / section link
  segments = routePath.split("/").filter(Boolean);
  sectionLabel = sectionLabelFromRoute(routePath);

  sectionSlug = segments.length > 0 ? segments[0] : null;
  sectionHref = sectionSlug ? normalizePath("/" + sectionSlug) : null;

  // TOC: keep h2/h3
  toc =
    Array.isArray(headings)
      ? headings
          .filter((h: any) => h.depth === 2 || h.depth === 3)
          .map((h: any) => {
            const text = stripHtml(h.text ?? "");
            return {
              depth: h.depth,
              text,
              slug: h.slug ?? slugToAnchor(text),
            };
          })
          .filter((h: any) => h.text)
      : [];

  hasToc = toc.length > 0;
  permalink = safeRouteFor(entry!);
}
---

<SiteLayout title={`${title} — Stand Up Arkansas`} noIndex={notFound}>
  <main class="doc">
    {notFound ? (
      <div class="card" style="padding: 16px;">
        <h1 style="margin:0 0 8px;">Page not found</h1>
        <p style="margin:0 0 14px; color: var(--text-muted);">
          We couldn’t find that page. Use the Library to browse the full structure.
        </p>
        <a class="btn primary" href="/library">Go to Library</a>
      </div>
    ) : (
      <div class="docGrid">
        <!-- LEFT: Main content -->
        <div class="docMain">
          <header class="docHeader card" aria-label="Document header">
            <div class="crumbs" aria-label="Breadcrumbs">
              <a class="crumbLink" href="/">Home</a>

              {sectionHref ? (
                <span class="crumbGroup">
                  <span class="crumbSep" aria-hidden="true">/</span>
                  <a class="crumbLink" href={sectionHref}>
                    {sectionLabel ?? titleizeSegment(sectionSlug!)}
                  </a>
                </span>
              ) : null}

              <span class="crumbSep" aria-hidden="true">/</span>
              <span class="crumbCurrent">{title}</span>
            </div>

            <div class="docHeaderRow">
              <h1 class="docTitle">{title}</h1>

              <div class="docActions" aria-label="Document actions">
                <a class="btn" href="/library">Library</a>
                <a class="btn primary" href={permalink}>Permalink</a>
              </div>
            </div>
          </header>

          <article class="prose docProse">
            {Content ? <Content /> : null}
          </article>

          {(prevEntry || nextEntry) ? (
            <nav class="docPager" aria-label="Previous and next">
              {prevEntry ? (
                <a class="btn" href={safeRouteFor(prevEntry)}>
                  ← Prev: {prevEntry.data.title ?? titleizeSegment(prevEntry.slug)}
                </a>
              ) : (
                <span class="pagerSpacer" aria-hidden="true"></span>
              )}

              {nextEntry ? (
                <a class="btn primary" href={safeRouteFor(nextEntry)}>
                  Next: {nextEntry.data.title ?? titleizeSegment(nextEntry.slug)} →
                </a>
              ) : null}
            </nav>
          ) : null}
        </div>

        <!-- RIGHT: TOC / section -->
        <aside class="docRail" aria-label="On this page">
          <div class="railCard card">
            <div class="railHead">
              <div class="railTitle">On this page</div>
              <div class="railHint">{hasToc ? "Jump to a section" : "No headings detected"}</div>
            </div>

            {hasToc ? (
              <ul class="toc" aria-label="Table of contents">
                {toc.map((h) => (
                  <li class={`tocItem ${h.depth === 3 ? "isH3" : "isH2"}`}>
                    <a class="tocLink" href={`#${h.slug}`}>{h.text}</a>
                  </li>
                ))}
              </ul>
            ) : (
              <div class="tocEmpty">
                If this is unexpected, ensure the source DOCX/MD has <code>##</code> or <code>###</code> headings.
              </div>
            )}

            {sectionHref ? (
              <div class="railFoot">
                <div class="railMetaLabel">Section</div>
                <a class="btn" href={sectionHref}>
                  {sectionLabel ?? titleizeSegment(sectionSlug!)} →
                </a>
              </div>
            ) : null}
          </div>
        </aside>
      </div>
    )}
  </main>

  <style>
    .doc{
      padding: 6px 0 18px;
    }

    .docGrid{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 16px;
      align-items:start;
    }

    .docMain{ min-width: 0; }
    .docRail{ min-width: 0; }

    .docHeader{
      padding: 14px 16px;
      margin-bottom: 18px;
      border-radius: var(--r-lg);
    }

    .crumbs{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      align-items:center;
      font-size: 12px;
      color: var(--text-subtle);
      margin-bottom: 10px;
    }

    .crumbGroup{
      display:inline-flex;
      gap: 8px;
      align-items:center;
    }

    .crumbLink{
      text-decoration:none;
      color: var(--text-muted);
      border-bottom: 1px solid transparent;
    }
    .crumbLink:hover{
      color: var(--text);
      border-bottom-color: rgba(var(--fg), .22);
    }

    .crumbSep{ opacity: .55; }

    .crumbCurrent{
      color: var(--text-muted);
      opacity: .92;
    }

    .docHeaderRow{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
    }

    .docTitle{
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.01em;
      color: var(--text);
      line-height: 1.25;
    }

    .docActions{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .docProse{ max-width: 920px; }

    .docPager{
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
      margin-top: 22px;
      align-items:center;
      justify-content:space-between;
    }
    .pagerSpacer{ display:none; }

    .railCard{
      padding: 14px 14px;
      border-radius: var(--r-lg);
      position: sticky;
      top: 96px;
    }

    .railHead{
      display:grid;
      gap: 4px;
      margin-bottom: 10px;
    }

    .railTitle{
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.01em;
    }

    .railHint{
      font-size: 12px;
      color: var(--text-subtle);
    }

    .toc{
      list-style:none;
      padding: 0;
      margin: 0;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }

    .tocItem{ margin: 0; }

    .tocItem.isH3{
      padding-left: 12px;
      border-left: 2px solid rgba(var(--border), .35);
      margin-left: 2px;
    }

    .tocLink{
      text-decoration:none;
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.35;
      border-bottom: 1px solid transparent;
    }
    .tocLink:hover{
      color: var(--text);
      border-bottom-color: rgba(var(--ring), .45);
    }

    .tocEmpty{
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
      padding: 10px 0 2px;
    }

    .railFoot{
      margin-top: 14px;
      border-top: 1px solid var(--stroke);
      padding-top: 12px;
      display:grid;
      gap: 8px;
    }

    .railMetaLabel{
      font-size: 12px;
      color: var(--text-subtle);
    }

    @media (max-width: 980px){
      .docGrid{ grid-template-columns: 1fr; }
      .railCard{ position: static; top: auto; }
      .docPager{ justify-content:flex-start; }
    }
  </style>
</SiteLayout>
